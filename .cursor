# BRANCH POLICY REMINDER
# Always work against the 'dev' branch for all development, except when explicitly instructed to use 'main'.
# This ensures safe, reviewable PRs and keeps main stable.

# CRITICAL BRANCH WORKFLOW RULE
# NEVER push directly to main branch. ALWAYS:
# 1. Work on dev branch
# 2. Make changes and commit to dev
# 3. Push to origin/dev
# 4. Create PR from dev to main
# 5. Merge via PR, never direct push to main
# This rule is non-negotiable for code safety and review process.

# Stinger LLM Guardrails Framework - Development Rules

## Code Quality & Architecture

### 1. Permission & Communication
- **NEVER** make changes to the repository without explicit instruction or asking first
- Always explain what you're planning to do before making changes
- If unsure about an approach, ask for clarification

### 2. Maintainable Code Principles
- Focus on **architecture re-use** - design components to be extensible
- Write code that's easy to understand, modify, and extend
- Prefer composition over inheritance where appropriate
- Keep functions and classes focused on single responsibilities

### 3. Code Organization
- If files exceed 200-300 lines, refactor into smaller, focused modules
- Break large classes into smaller, cohesive components
- Extract common patterns into reusable utilities
- Maintain clear separation of concerns

### 4. Code Quality Standards
- Write code that **people will actually read and understand**
- Use descriptive variable and function names
- Add meaningful comments for complex logic
- Follow Python best practices and PEP 8 style guidelines
- The codebase should be a pleasure to work with

## Testing Philosophy

### 5. Test Quality Over Quantity
- **Tests must actually TEST functionality** - no useless unit tests
- **NEVER fudge test results** to meet deadlines or make anyone happy
- If tests are failing, fix the code, not the tests
- Write tests that catch real bugs and prevent regressions
- Focus on integration tests that verify the system works end-to-end
- Test edge cases and error conditions

### 6. Test-Driven Development
- Write tests first when adding new features
- Ensure tests fail before implementing the feature
- Make the code pass the hard tests, not the easy ones
- Maintain high test coverage for critical paths

## Development Workflow

### 7. Incremental Development
- Build features incrementally with working code at each step
- Commit frequently with meaningful commit messages
- Test thoroughly before pushing changes
- Keep the main branch stable and working

### 8. Documentation
- Keep README and documentation up to date
- Document complex algorithms and design decisions
- Include examples and usage patterns
- Make the project accessible to new contributors

## Commit and Workflow Guidelines

### 7. Commit Batching (CRITICAL)
- **BATCH CHANGES**: Group related changes together before committing
- **NO MICRO-COMMITS**: Don't commit after every small change or file edit
- **MEANINGFUL BATCHES**: Wait until you have a complete feature, fix, or logical group of changes
- **EXAMPLES OF GOOD BATCHING**:
  - All documentation updates together
  - Complete feature implementation with tests
  - All related refactoring changes
  - All example/demo updates together
- **EXAMPLES OF WHAT TO AVOID**:
  - Committing after each README edit
  - Committing individual file changes
  - Committing before completing a logical unit of work

### 8. Commit Message Standards
- Use descriptive, meaningful commit messages
- Include context about what was changed and why
- Reference issue numbers when applicable
- Use present tense ("Add feature" not "Added feature")

### 9. Push Strategy
- **PUSH BATCHES**: Only push when you have meaningful changes to share
- **REVIEW BEFORE PUSH**: Ensure all changes in the batch are complete and tested
- **AVOID PUSHING PARTIAL WORK**: Don't push incomplete features or broken code

### 10. Workflow Best Practices
- Make all related changes first
- Test the complete set of changes
- Commit everything together with a comprehensive message
- Push once with the complete batch
- Create PRs for significant changes

## Project-Specific Guidelines

### 9. Filter Development
- All filters must inherit from BaseFilter
- Implement proper error handling and graceful degradation
- Add comprehensive test cases for each filter
- Document filter configuration options

### 10. Configuration Management
- Validate configuration files thoroughly
- Provide clear error messages for invalid configs
- Support backward compatibility when possible
- Document all configuration options

### 11. Issue Management
- Use GitHub CLI (`gh issue create`, `gh issue list`, etc.) to manage issues directly from terminal
- Avoid copy/paste by using `--body-file` flag for issue content
- Example: `gh issue create --title "Title" --body-file issue.md`

## Code Review Checklist

Before submitting any changes:
- [ ] Code follows project architecture patterns
- [ ] Tests are meaningful and pass
- [ ] Documentation is updated
- [ ] Error handling is implemented
- [ ] Code is readable and maintainable
- [ ] No unnecessary complexity added

## Remember
**Quality over speed. Architecture over quick fixes. Tests that actually test.**

# Cursor configuration for Stinger project

# IMPORTANT: Always use "gpt-4.1-nano" as the base model for AI filters, NOT "gpt-4o-mini"
# This has been discussed and agreed upon - gpt-4.1-nano is the correct model name
# Use this consistently across all AI-based filters and adapters

# Project-specific settings
{
  "projectName": "Stinger",
  "defaultModel": "gpt-4.1-nano",
  "aiFilters": {
    "contentModeration": "gpt-4.1-nano",
    "promptInjection": "gpt-4.1-nano", 
    "piiDetection": "gpt-4.1-nano",
    "toxicityDetection": "gpt-4.1-nano",
    "codeGeneration": "gpt-4.1-nano"
  }
}

# ---
# NOTES ON GITHUB ISSUE HANDLING (for future reference)
#
# - Preferred: Use GitHub CLI (gh issue list, gh issue close) for listing and closing issues.
#   - If CLI output is broken, try using the GitHub API with curl for listing issues:
#     curl -s "https://api.github.com/repos/virtualsteve-star/stinger/issues?state=open" | jq '.[] | {number, title, state}'
#   - To close issues via API, use a PATCH request with a personal access token.
# - If all else fails, review and close issues manually via the GitHub web interface.
# - Always add a relevant comment when closing issues, referencing code, tests, or documentation as appropriate.
# - Document any changes to issue handling in this section for future maintainers.

# .cursor configuration
# Always use 'virtualsteve-star/stinger' as the GitHub repo for CLI and issue-related actions
GITHUB_REPO=virtualsteve-star/stinger

# DATE REMINDER
# ALWAYS use the real current date when documenting completion dates, timestamps, or any time-related information
# Run 'date' command to get the current date/time before writing dates in documentation
# Never assume or guess dates - always verify with the system date

# PROCESS TESTING RULES
# - **NEVER use `command &` with Bash tool** - causes hanging when trying to capture output
# - **For long-running services:** test endpoints directly, don't background processes
# - **If testing startup:** use wrapper scripts that exit quickly or test specific functionality
# - **Examples:**
#   - ❌ `python3 server.py &` (will hang)
#   - ✅ `curl http://localhost:8000/health` (test endpoint)
#   - ✅ Start process, let user interrupt, then verify it worked

# ---
# API KEY ENVIRONMENT VARIABLE HANDLING (Stinger)
#
# - API keys (e.g., OPENAI_API_KEY) should be set as environment variables, preferably using macOS Keychain for devs using Cursor or similar tools.
# - The recommended workflow is:
#     1. Store the key in Keychain: security add-generic-password -a "$USER" -s openai-api-key -w 'sk-...'
#     2. Expose it as an environment variable: launchctl setenv OPENAI_API_KEY $(security find-generic-password -w -s openai-api-key)
# - The Stinger centralized API key manager will automatically pick up the key from the environment.
# - All filters and services must use the centralized manager for key access (never read keys directly from config or os.environ).
# - See docs/API_KEY_HANDLING.md for full details.
# ---

# NOTE: For GitHub PRs and commit messages, use real newlines (not \n) in PR bodies for clean formatting in the web UI.
# Example (correct):
#   gh pr create --title "My PR Title" --body "\

# ---
# LINE COUNTING GUIDELINES (Stinger Project)
#
# When counting lines of code in the Stinger project, be careful to avoid double counting:
#
# PRODUCTION CODE:
#   find . -name "*.py" -not -path "./tests/*" -not -path "./demos/*" -not -path "./examples/*" -not -path "./docs/*" -not -path "./.git/*" -not -path "./venv/*" -not -path "./__pycache__/*" -not -path "./*.egg-info/*"
#
# TEST CODE (./tests/ directory only):
#   find ./tests -name "*.py"
#
# DEMO CODE (./demos/ excluding test files):
#   find ./demos -name "*.py" -not -name "test_*.py"
#
# DEMO TEST CODE (./demos/ test files only):
#   find ./demos -name "test_*.py"
#
# EXAMPLE CODE:
#   find ./examples -name "*.py"
#
# IMPORTANT: The ./demos/ directory contains BOTH demo code AND test files.
# - Demo test files (test_*.py) should be counted as TEST CODE, not demo code
# - This prevents double counting when reporting test vs demo vs production ratios
#
# CORRECT BREAKDOWN:
# - Production: 36.8% (13,136 lines)
# - Test Code (./tests/): 29.7% (10,617 lines)  
# - Demo Test Code (./demos/test_*.py): 15.6% (5,598 lines)
# - Demo Code (./demos/ excluding tests): 14.8% (5,305 lines)
# - Example Code: 2.8% (1,016 lines)
# - TOTAL TEST CODE: 45.4% (16,215 lines)
# - TOTAL DEMO/EXAMPLE CODE: 17.7% (6,321 lines)
# ---
#   Line 1 of description
#   
#   Line 2 of description
#   "
# Or use a file:
#   gh pr create --title "My PR Title" --body "$(cat path/to/message.md)"
#
# Avoid passing --body with \n escape sequences, as these will render as literal text in GitHub.

# ---
# GITHUB ISSUE AND PR CREATION WORKFLOW (RECOMMENDED PRACTICE)
#
# For all detailed, markdown-rich, or multiline issue/PR bodies, ALWAYS use a file:
#   - For issues: gh issue create --title "Title" --body-file issue.md
#   - For PRs:    gh pr create --title "Title" --body "$(cat pr_description.md)" --base main --head dev
#
# Avoid using --body with long or complex strings directly, as this may silently fail or truncate content.
#
# LABELS: Only use labels that already exist in the repo. Specifying a non-existent label will cause silent failure.
#
# EXAMPLES:
#   echo "Full issue or PR body here" > body.md
#   gh issue create --title "My Issue" --body-file body.md
#   gh pr create --title "My PR" --body "$(cat body.md)" --base main --head dev
#   rm body.md
#
# This is the most reliable way to ensure all content is included and formatted correctly.
# --- 